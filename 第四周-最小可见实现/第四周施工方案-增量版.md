# 第四周施工方案 - 基于第三周成果的增量完善
# Week 4 Implementation - Incremental Enhancement Based on Week 3

**创建时间**: 2025-08-26  
**版本**: 6.0 (增量版)  
**核心理念**: 不否定第三周，而是补全缺失的关键实现  
**目标**: 让已有的框架真正工作起来

---

## 🎯 第三周成果评估与第四周定位

### 第三周的有价值成果
✅ **基础框架已搭建**
- tty.c 路由逻辑已添加（Line 1741-1750）
- ui_backend 基础结构存在
- libtmuxcore.dylib 已构建
- Ghostty FFI 模块已创建

### 第三周的关键缺失
❌ **核心功能未实现**
- ui_backend_dispatch 只是 stub（Line 93-97 有TODO）
- 没有识别具体的 tty_cmd_* 函数
- 回调函数表未定义和连接
- Terminal.zig 未集成

### 第四周的任务
**补全缺失的实现，让框架真正工作**

---

## 📊 第四周增量实现计划

### Day 1-2: 增强 ui_backend_dispatch 实现

#### 任务 W4-INC-001: 让 ui_backend_dispatch 真正工作
**文件**: `tmux/ui_backend/ui_backend_dispatch.c` (新建)
**目标**: 实现真正的命令分发

```c
// tmux/ui_backend/ui_backend_dispatch.c
#include "ui_backend.h"
#include "../tmux.h"
#include <stdio.h>

// 回调函数表 - 这是第三周缺失的关键部分
typedef struct {
    void (*on_cell)(const char ch, int row, int col, void* user_data);
    void (*on_clear_line)(int row, void* user_data);
    void (*on_flush)(void* user_data);
} ui_callbacks_t;

static ui_callbacks_t g_callbacks = {0};
static void* g_user_data = NULL;

// 设置回调 - 供Ghostty调用
void ui_backend_set_callbacks(ui_callbacks_t* callbacks, void* user_data) {
    if (callbacks) {
        g_callbacks = *callbacks;
        g_user_data = user_data;
        printf("[UI_BACKEND] Callbacks registered\n");
    }
}

// 增强版的 dispatch 函数 - 替换原来的stub
int ui_backend_dispatch_enhanced(ui_backend_t* backend,
                                void (*cmdfn)(struct tty *, const struct tty_ctx *),
                                struct tty_ctx* ctx) {
    // 检查是否为GHOSTTY模式
    if (!backend || !ui_backend_enabled()) {
        return -1;
    }
    
    // 识别是哪个 tty_cmd_* 函数 - 第三周缺失的关键逻辑
    if (cmdfn == tty_cmd_cell) {
        printf("[DISPATCH] Processing tty_cmd_cell\n");
        
        if (ctx->cell && g_callbacks.on_cell) {
            struct grid_cell* gc = ctx->cell;
            char ch = gc->data.data[0];
            
            // 调用回调 - 发送给Ghostty
            g_callbacks.on_cell(ch, ctx->ocy, ctx->ocx, g_user_data);
            printf("[DISPATCH] Cell '%c' at (%d,%d) sent to callback\n", 
                   ch, ctx->ocy, ctx->ocx);
        }
        return 0; // 已处理
        
    } else if (cmdfn == tty_cmd_clearline) {
        printf("[DISPATCH] Processing tty_cmd_clearline\n");
        
        if (g_callbacks.on_clear_line) {
            g_callbacks.on_clear_line(ctx->ocy, g_user_data);
        }
        return 0; // 已处理
    }
    
    // 其他命令暂不处理
    return -1; // 使用原路径
}
```

#### 任务 W4-INC-002: 修改现有 ui_backend.c 调用新的 dispatch
**文件**: `tmux/ui_backend/ui_backend.c`
**修改**: Line 79-104

```c
// 在 ui_backend.c 中修改 ui_backend_dispatch 函数
// 替换原来的 TODO 部分

// 声明外部函数
extern int ui_backend_dispatch_enhanced(ui_backend_t* backend,
                                       void (*cmdfn)(struct tty *, const struct tty_ctx *),
                                       struct tty_ctx* ctx);

int ui_backend_dispatch(ui_backend_t* backend, 
                        void (*cmdfn)(struct tty *, const struct tty_ctx *),
                        struct tty_ctx* ctx) {
    #ifdef LIBTMUXCORE_BUILD
    if (!g_backend.enabled || g_backend.router == NULL) {
        return -1;
    }
    
    // 使用增强版的 dispatch
    if (g_backend.router->mode == ROUTER_MODE_GHOSTTY) {
        return ui_backend_dispatch_enhanced(backend, cmdfn, ctx);
    }
    
    return -1;
    #else
    return -1;
    #endif
}
```

### Day 3: 创建 C-Zig 桥接层

#### 任务 W4-INC-003: 创建 FFI 桥接函数
**文件**: `ghostty/src/tmux/ffi_bridge.zig`
**目标**: 连接 C 回调到 Zig

```zig
// ghostty/src/tmux/ffi_bridge.zig
const std = @import("std");

// C 回调函数类型定义
pub const CellCallback = *const fn(ch: u8, row: c_int, col: c_int, user_data: ?*anyopaque) callconv(.C) void;
pub const ClearLineCallback = *const fn(row: c_int, user_data: ?*anyopaque) callconv(.C) void;
pub const FlushCallback = *const fn(user_data: ?*anyopaque) callconv(.C) void;

// 回调函数表 - 对应 C 的 ui_callbacks_t
pub const UICallbacks = extern struct {
    on_cell: ?CellCallback,
    on_clear_line: ?ClearLineCallback,
    on_flush: ?FlushCallback,
};

// 外部 C 函数声明
extern fn ui_backend_set_callbacks(callbacks: *const UICallbacks, user_data: ?*anyopaque) void;
extern fn ui_backend_init() void;
extern fn ui_backend_enabled() bool;

// Zig 端的回调处理器
pub const CallbackHandler = struct {
    grid: [][]u8,
    rows: usize,
    cols: usize,
    
    pub fn init(rows: usize, cols: usize, allocator: std.mem.Allocator) !CallbackHandler {
        var grid = try allocator.alloc([]u8, rows);
        for (grid) |*row| {
            row.* = try allocator.alloc(u8, cols);
            @memset(row.*, ' ');
        }
        
        return CallbackHandler{
            .grid = grid,
            .rows = rows,
            .cols = cols,
        };
    }
    
    // C 回调实现
    pub fn onCell(ch: u8, row: c_int, col: c_int, user_data: ?*anyopaque) callconv(.C) void {
        const self = @ptrCast(*CallbackHandler, @alignCast(@alignOf(CallbackHandler), user_data));
        
        const r = @intCast(usize, row);
        const c = @intCast(usize, col);
        
        if (r < self.rows and c < self.cols) {
            self.grid[r][c] = ch;
            std.debug.print("[ZIG] Cell '{c}' at ({},{}) received\n", .{ch, r, c});
        }
    }
    
    pub fn onClearLine(row: c_int, user_data: ?*anyopaque) callconv(.C) void {
        const self = @ptrCast(*CallbackHandler, @alignCast(@alignOf(CallbackHandler), user_data));
        
        const r = @intCast(usize, row);
        if (r < self.rows) {
            @memset(self.grid[r], ' ');
            std.debug.print("[ZIG] Line {} cleared\n", .{r});
        }
    }
    
    pub fn onFlush(user_data: ?*anyopaque) callconv(.C) void {
        const self = @ptrCast(*CallbackHandler, @alignCast(@alignOf(CallbackHandler), user_data));
        std.debug.print("[ZIG] Flush requested\n", .{});
        self.displayGrid();
    }
    
    pub fn displayGrid(self: *CallbackHandler) void {
        std.debug.print("\n--- Grid Display ---\n", .{});
        for (self.grid) |row| {
            for (row) |ch| {
                std.debug.print("{c}", .{ch});
            }
            std.debug.print("\n", .{});
        }
        std.debug.print("--- End Display ---\n", .{});
    }
    
    pub fn registerCallbacks(self: *CallbackHandler) void {
        const callbacks = UICallbacks{
            .on_cell = onCell,
            .on_clear_line = onClearLine,
            .on_flush = onFlush,
        };
        
        ui_backend_set_callbacks(&callbacks, self);
        std.debug.print("[ZIG] Callbacks registered with UI Backend\n", .{});
    }
};
```

### Day 4: 集成到 Terminal.zig

#### 任务 W4-INC-004: 修改 Terminal.zig 使用桥接
**文件**: `ghostty/src/terminal/Terminal.zig`
**目标**: 初始化并连接回调

```zig
// 在 Terminal.zig 中添加
const ffi_bridge = @import("../tmux/ffi_bridge.zig");

pub const Terminal = struct {
    // ... 原有字段
    
    // 新增
    tmux_handler: ?*ffi_bridge.CallbackHandler,
    
    pub fn init(allocator: std.mem.Allocator, config: Config) !Terminal {
        var self = Terminal{
            // ... 原有初始化
            .tmux_handler = null,
        };
        
        // 检查环境变量
        if (std.process.getEnv("GHOSTTY_TMUX")) |_| {
            std.debug.print("[TERMINAL] Initializing tmux mode\n", .{});
            
            // 初始化 UI Backend
            ffi_bridge.ui_backend_init();
            
            // 创建回调处理器
            self.tmux_handler = try allocator.create(ffi_bridge.CallbackHandler);
            self.tmux_handler.?.* = try ffi_bridge.CallbackHandler.init(
                config.rows, 
                config.cols, 
                allocator
            );
            
            // 注册回调
            self.tmux_handler.?.registerCallbacks();
            
            std.debug.print("[TERMINAL] tmux callbacks registered\n", .{});
        }
        
        return self;
    }
    
    pub fn render(self: *Terminal) void {
        if (self.tmux_handler) |handler| {
            // 显示 tmux 的 grid
            handler.displayGrid();
        } else {
            // 普通渲染
            self.renderNormal();
        }
    }
};
```

### Day 5: 创建测试程序

#### 任务 W4-INC-005: 创建端到端测试
**文件**: `test_week4_integration.c`
**目标**: 验证整个链路

```c
// test_week4_integration.c
#include <stdio.h>
#include <string.h>
#include "../tmux/tmux.h"
#include "../tmux/ui_backend/ui_backend.h"

// 模拟 tty_cmd_cell 函数
void tty_cmd_cell(struct tty* tty, const struct tty_ctx* ctx) {
    printf("[TEST] Original tty_cmd_cell called\n");
}

// 测试回调
void test_on_cell(char ch, int row, int col, void* user_data) {
    printf("[TEST CALLBACK] Received cell '%c' at (%d,%d)\n", ch, row, col);
}

int main() {
    printf("=== Week 4 Integration Test ===\n");
    
    // 设置环境变量
    setenv("TMUX_UI_BACKEND", "ghostty", 1);
    
    // 初始化 UI Backend
    ui_backend_init();
    
    // 设置测试回调
    ui_callbacks_t callbacks = {
        .on_cell = test_on_cell,
        .on_clear_line = NULL,
        .on_flush = NULL
    };
    ui_backend_set_callbacks(&callbacks, NULL);
    
    // 创建测试数据
    struct grid_cell cell = {
        .data = { .data = "H" },
    };
    
    struct tty_ctx ctx = {
        .cell = &cell,
        .ocy = 0,
        .ocx = 0,
    };
    
    // 测试 dispatch
    ui_backend_t* backend = ui_backend_get_instance();
    int result = ui_backend_dispatch(backend, tty_cmd_cell, &ctx);
    
    if (result == 0) {
        printf("✅ Dispatch successful - callback should have been called\n");
    } else {
        printf("❌ Dispatch failed\n");
    }
    
    printf("=== Test Complete ===\n");
    return 0;
}
```

### Day 6: 构建和测试脚本

#### 任务 W4-INC-006: 创建增量构建脚本
**文件**: `build_week4.sh`

```bash
#!/bin/bash
set -e

echo "=== Week 4 Incremental Build ==="

# 编译新的 dispatch 实现
cd tmux/ui_backend
gcc -c -fPIC ui_backend_dispatch.c -o ui_backend_dispatch.o

# 重新链接 libtmuxcore.dylib
cd ..
gcc -dynamiclib -o libtmuxcore.dylib \
    ui_backend/*.o \
    -DLIBTMUXCORE_BUILD

echo "✅ libtmuxcore.dylib updated"

# 编译测试程序
gcc -o test_week4 test_week4_integration.c \
    -L. -ltmuxcore \
    -DLIBTMUXCORE_BUILD

# 运行测试
export DYLD_LIBRARY_PATH=.:$DYLD_LIBRARY_PATH
./test_week4

echo "=== Build Complete ==="
```

---

## 🎯 第四周成功标准

### 最小目标
✅ ui_backend_dispatch 能识别 tty_cmd_cell  
✅ 回调函数被正确触发  
✅ Zig 端能接收到字符数据  
✅ 能看到 "H" 字符被处理  

### 增量改进
- 基于第三周的框架工作
- 不推翻重来，而是补全缺失
- 保持代码连续性

---

## 💡 为什么这个方案更好

1. **尊重第三周的工作** - 不否定已有成果
2. **增量改进** - 只补充缺失的部分
3. **明确的问题定位** - ui_backend_dispatch 需要真正实现
4. **可验证的进展** - 每一步都能看到效果

这个方案承认第三周的价值，同时补全了关键的缺失部分！