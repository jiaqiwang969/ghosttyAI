# 第四周施工方案 - 最小可见目标：显示 "Hello from tmux"
# Week 4 Implementation Plan - Minimal Goal: Display "Hello from tmux"

**创建时间**: 2025-08-26  
**版本**: 5.0 (务实版)  
**核心目标**: 打通回调链路，能在 Ghostty 中看到 tmux 的输出  
**成功标准**: `echo "Hello from tmux"` 能正确显示

---

## 🎯 第四周核心任务：补全缺失的关键实现

### 现状分析
```
第三周声称完成但实际缺失：
❌ UI Backend Router (只有stub)
❌ tty.c 路由修改 (没有真正修改)
❌ 回调链路 (完全断开)
❌ Terminal.zig 集成 (没有调用tmux)
```

### 本周目标
```
最小可见验证：
✅ tmux 输出 "Hello from tmux"
✅ 通过回调传递给 Ghostty
✅ Ghostty 显示这个文本
```

---

## 📊 第四周详细任务分解

### Day 1: 实现真正的 UI Backend Router

#### 任务 W4-001: 创建真正能工作的 ui_backend.c
**位置**: `tmux/ui_backend.c`
**目标**: 不是stub，是真正的实现

```c
// tmux/ui_backend.c - 真正的实现，不是stub！
#include "tmux.h"
#include <stdio.h>

// 全局回调函数指针 - 简单直接
static void (*g_on_text_callback)(const char* text, size_t len) = NULL;
static void* g_user_data = NULL;

// UI Backend 结构
struct ui_backend {
    int enabled;
    // 简单的文本缓冲区
    char buffer[1024];
    size_t buffer_pos;
};

// 全局backend实例
static struct ui_backend g_backend = {
    .enabled = 0,
    .buffer = {0},
    .buffer_pos = 0
};

// 初始化backend
void ui_backend_init(void) {
    printf("[UI_BACKEND] Initializing...\n");
    g_backend.enabled = 1;
    g_backend.buffer_pos = 0;
}

// 设置回调 - 这是连接到Ghostty的关键
void ui_backend_set_callback(void (*callback)(const char*, size_t), void* user_data) {
    printf("[UI_BACKEND] Setting callback: %p\n", callback);
    g_on_text_callback = callback;
    g_user_data = user_data;
}

// 核心函数：处理tty_cmd_cell - 最重要的函数
void ui_backend_cell(struct tty_ctx* ctx) {
    if (!g_backend.enabled) return;
    
    struct grid_cell* gc = ctx->cell;
    if (gc == NULL) return;
    
    // 提取字符
    char ch = gc->data.data[0];
    if (ch == 0) return;
    
    printf("[UI_BACKEND] Got cell: '%c' (0x%02x)\n", ch, ch);
    
    // 添加到缓冲区
    if (g_backend.buffer_pos < sizeof(g_backend.buffer) - 1) {
        g_backend.buffer[g_backend.buffer_pos++] = ch;
    }
    
    // 如果是换行符或缓冲区满，刷新
    if (ch == '\n' || g_backend.buffer_pos >= sizeof(g_backend.buffer) - 1) {
        ui_backend_flush();
    }
}

// 刷新缓冲区 - 触发回调
void ui_backend_flush(void) {
    if (g_backend.buffer_pos == 0) return;
    
    g_backend.buffer[g_backend.buffer_pos] = '\0';
    printf("[UI_BACKEND] Flushing: '%s'\n", g_backend.buffer);
    
    // 调用回调 - 发送给Ghostty！
    if (g_on_text_callback != NULL) {
        g_on_text_callback(g_backend.buffer, g_backend.buffer_pos);
    }
    
    // 清空缓冲区
    g_backend.buffer_pos = 0;
}

// 检查是否启用
int ui_backend_enabled(void) {
    return g_backend.enabled;
}
```

### Day 2: 修改 tty.c 添加真正的路由

#### 任务 W4-002: 修改 tty.c 实现路由
**位置**: `tmux/tty.c`
**目标**: 真正拦截 tty_write 并路由到 backend

```c
// tmux/tty.c - 在文件开头添加
#ifdef LIBTMUXCORE_BUILD
#include "ui_backend.h"
extern void ui_backend_cell(struct tty_ctx* ctx);
extern int ui_backend_enabled(void);
#endif

// 找到 tty_cmd_cell 函数并修改
void
tty_cmd_cell(struct tty *tty, const struct tty_ctx *ctx)
{
    #ifdef LIBTMUXCORE_BUILD
    // 如果UI Backend启用，路由到backend
    if (ui_backend_enabled()) {
        printf("[TTY] Routing cell to UI Backend\n");
        ui_backend_cell((struct tty_ctx*)ctx);
        return;  // 不执行原有的TTY输出！
    }
    #endif
    
    // 原有的TTY输出代码...
    if (!tty_is_visible(tty, ctx, ctx->ocx, ctx->ocy, 1, 1))
        return;
    // ... 原有代码继续
}

// 找到 tty_cmd_insertcharacter 等其他函数，也添加类似路由
// 但为了简单，我们先只处理 cell
```

### Day 3: 创建 Ghostty 端的回调接收器

#### 任务 W4-003: 实现 Ghostty 回调处理
**位置**: `ghostty/src/tmux/simple_callback.zig`
**目标**: 最简单的回调处理，能显示文本就行

```zig
// ghostty/src/tmux/simple_callback.zig
const std = @import("std");
const c = @cImport({
    @cInclude("libtmuxcore.h");
});

// 简单的回调处理器
pub const SimpleCallback = struct {
    received_text: std.ArrayList(u8),
    
    pub fn init(allocator: std.mem.Allocator) SimpleCallback {
        return .{
            .received_text = std.ArrayList(u8).init(allocator),
        };
    }
    
    pub fn deinit(self: *SimpleCallback) void {
        self.received_text.deinit();
    }
    
    // C回调函数 - 接收来自tmux的文本
    pub fn onTextCallback(
        text: [*c]const u8,
        len: usize,
        user_data: ?*anyopaque,
    ) callconv(.C) void {
        const self = @ptrCast(*SimpleCallback, @alignCast(@alignOf(SimpleCallback), user_data));
        
        // 打印调试信息
        std.debug.print("[GHOSTTY] Received from tmux: {s}\n", .{text[0..len]});
        
        // 保存文本
        self.received_text.appendSlice(text[0..len]) catch {
            std.debug.print("[GHOSTTY] Failed to append text\n", .{});
        };
    }
    
    pub fn getText(self: *SimpleCallback) []const u8 {
        return self.received_text.items;
    }
    
    pub fn clear(self: *SimpleCallback) void {
        self.received_text.clearRetainingCapacity();
    }
};
```

### Day 4: 修改 Terminal.zig 集成回调

#### 任务 W4-004: 让 Terminal.zig 真正使用 tmux
**位置**: `ghostty/src/terminal/Terminal.zig`
**目标**: 初始化 tmux 并显示其输出

```zig
// ghostty/src/terminal/Terminal.zig - 添加tmux集成
const std = @import("std");
const SimpleCallback = @import("../tmux/simple_callback.zig").SimpleCallback;

// 声明外部C函数
extern fn ui_backend_init() void;
extern fn ui_backend_set_callback(
    callback: *const fn([*c]const u8, usize) callconv(.C) void,
    user_data: ?*anyopaque
) void;
extern fn tmc_create() ?*anyopaque;
extern fn tmc_initialize(ctx: ?*anyopaque) c_int;

pub const Terminal = struct {
    // 原有字段
    allocator: std.mem.Allocator,
    cols: u32,
    rows: u32,
    grid: [][]Cell,
    
    // 新增：tmux集成
    tmux_enabled: bool,
    tmux_callback: ?*SimpleCallback,
    tmux_context: ?*anyopaque,
    
    pub fn init(allocator: std.mem.Allocator, cols: u32, rows: u32) !Terminal {
        var self = Terminal{
            .allocator = allocator,
            .cols = cols,
            .rows = rows,
            .grid = try allocator.alloc([]Cell, rows),
            .tmux_enabled = false,
            .tmux_callback = null,
            .tmux_context = null,
        };
        
        // 初始化grid
        for (self.grid) |*row| {
            row.* = try allocator.alloc(Cell, cols);
            for (row.*) |*cell| {
                cell.* = Cell{ .char = ' ', .fg = 7, .bg = 0 };
            }
        }
        
        // 检查环境变量
        if (std.process.getEnv("GHOSTTY_TMUX")) |_| {
            std.debug.print("[TERMINAL] Enabling tmux mode\n", .{});
            try self.initTmux();
        }
        
        return self;
    }
    
    fn initTmux(self: *Terminal) !void {
        // 初始化UI Backend
        ui_backend_init();
        
        // 创建回调处理器
        self.tmux_callback = try self.allocator.create(SimpleCallback);
        self.tmux_callback.?.* = SimpleCallback.init(self.allocator);
        
        // 设置回调
        ui_backend_set_callback(
            SimpleCallback.onTextCallback,
            self.tmux_callback,
        );
        
        // 创建tmux context
        self.tmux_context = tmc_create();
        if (self.tmux_context == null) {
            std.debug.print("[TERMINAL] Failed to create tmux context\n", .{});
            return;
        }
        
        // 初始化tmux
        const result = tmc_initialize(self.tmux_context);
        if (result != 0) {
            std.debug.print("[TERMINAL] Failed to initialize tmux\n", .{});
            return;
        }
        
        self.tmux_enabled = true;
        std.debug.print("[TERMINAL] tmux mode initialized!\n", .{});
    }
    
    pub fn render(self: *Terminal) void {
        if (self.tmux_enabled and self.tmux_callback != null) {
            // 获取tmux的输出
            const text = self.tmux_callback.?.getText();
            if (text.len > 0) {
                std.debug.print("[RENDER] Displaying tmux output: {s}\n", .{text});
                
                // 简单地将文本显示在第一行
                var col: u32 = 0;
                for (text) |ch| {
                    if (col >= self.cols or ch == '\n') break;
                    self.grid[0][col].char = ch;
                    col += 1;
                }
                
                // 清空已处理的文本
                self.tmux_callback.?.clear();
            }
        }
        
        // 渲染grid到屏幕
        self.renderGrid();
    }
    
    fn renderGrid(self: *Terminal) void {
        std.debug.print("\n--- Terminal Display ---\n", .{});
        for (self.grid) |row| {
            for (row) |cell| {
                std.debug.print("{c}", .{cell.char});
            }
            std.debug.print("\n", .{});
        }
        std.debug.print("--- End Display ---\n", .{});
    }
};

const Cell = struct {
    char: u8,
    fg: u8,
    bg: u8,
};
```

### Day 5: 创建测试程序

#### 任务 W4-005: 创建简单的测试程序
**位置**: `test_hello_tmux.c`
**目标**: 验证整个链路

```c
// test_hello_tmux.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "libtmuxcore.h"

// 外部函数声明
extern void ui_backend_init(void);
extern void ui_backend_flush(void);

// 回调函数 - 打印收到的文本
void on_text_callback(const char* text, size_t len) {
    printf("[TEST] Callback received: '%.*s'\n", (int)len, text);
}

int main() {
    printf("=== Testing tmux Hello World ===\n");
    
    // 初始化UI Backend
    ui_backend_init();
    ui_backend_set_callback(on_text_callback, NULL);
    
    // 创建tmux context
    tmc_context_t* ctx = tmc_create();
    if (!ctx) {
        printf("Failed to create tmux context\n");
        return 1;
    }
    
    // 初始化
    if (tmc_initialize(ctx, NULL) != 0) {
        printf("Failed to initialize tmux\n");
        return 1;
    }
    
    // 发送测试文本
    const char* test_text = "Hello from tmux\n";
    printf("Sending: %s", test_text);
    tmc_process_input(ctx, test_text, strlen(test_text));
    
    // 强制刷新
    ui_backend_flush();
    
    // 清理
    tmc_destroy(ctx);
    
    printf("=== Test Complete ===\n");
    return 0;
}
```

### Day 6: 编译和测试脚本

#### 任务 W4-006: 创建构建和测试脚本
**位置**: `week4_test.sh`
**目标**: 自动化构建和测试

```bash
#!/bin/bash
set -e

echo "=== Week 4 Test: Hello from tmux ==="

# Step 1: 编译tmux with UI Backend
echo "[1/5] Compiling tmux with UI Backend..."
cd tmux
make clean
make CFLAGS="-DLIBTMUXCORE_BUILD -DUI_BACKEND_ENABLED" || {
    echo "Failed to compile tmux"
    exit 1
}

# Step 2: 构建libtmuxcore.dylib
echo "[2/5] Building libtmuxcore.dylib..."
gcc -shared -fPIC -o libtmuxcore.dylib \
    ui_backend.c \
    libtmuxcore.c \
    -DLIBTMUXCORE_BUILD \
    -L. -ltmux \
    || {
    echo "Failed to build libtmuxcore.dylib"
    exit 1
}

# Step 3: 编译测试程序
echo "[3/5] Compiling test program..."
gcc -o test_hello_tmux test_hello_tmux.c \
    -L. -ltmuxcore \
    -DLIBTMUXCORE_BUILD \
    || {
    echo "Failed to compile test program"
    exit 1
}

# Step 4: 运行C测试
echo "[4/5] Running C test..."
export DYLD_LIBRARY_PATH=.:$DYLD_LIBRARY_PATH
./test_hello_tmux

# Step 5: 编译和运行Ghostty测试
echo "[5/5] Testing with Ghostty..."
cd ../ghostty
zig build-exe src/test_terminal.zig \
    --library c \
    --library ../tmux/libtmuxcore.dylib \
    -DGHOSTTY_TMUX \
    || {
    echo "Failed to compile Ghostty test"
    exit 1
}

# 运行Ghostty测试
GHOSTTY_TMUX=1 ./test_terminal

echo "=== Week 4 Test Complete ==="
echo "If you see 'Hello from tmux' above, the callback chain is working!"
```

---

## 🎯 第四周成功标准

### 最小可见目标
1. ✅ 运行测试时能看到 `[UI_BACKEND] Got cell: 'H'` 等调试输出
2. ✅ 能看到 `[GHOSTTY] Received from tmux: Hello from tmux`
3. ✅ 最终能在 Terminal 的 grid 中看到 "Hello from tmux"

### 不追求的目标（本周）
- ❌ 完美的渲染
- ❌ 复杂的布局
- ❌ 高性能
- ❌ 完整功能

---

## 📋 每日执行计划

### Day 1 (周一)
- 上午：实现 ui_backend.c
- 下午：编译测试
- 验证：`ui_backend_init()` 能被调用

### Day 2 (周二)
- 上午：修改 tty.c 添加路由
- 下午：重新编译 tmux
- 验证：看到 `[TTY] Routing cell to UI Backend` 输出

### Day 3 (周三)
- 上午：实现 SimpleCallback.zig
- 下午：编译测试
- 验证：回调函数编译通过

### Day 4 (周四)
- 上午：修改 Terminal.zig
- 下午：集成测试
- 验证：tmux初始化成功

### Day 5 (周五)
- 上午：创建测试程序
- 下午：调试链路
- 验证：回调被触发

### Day 6 (周六)
- 上午：完整测试
- 下午：修复问题
- 验证：看到 "Hello from tmux"

---

## 💡 调试技巧

### 如果看不到输出
1. 检查每一步的 printf/debug.print 输出
2. 确认 ui_backend_enabled() 返回 1
3. 确认回调函数指针不为 NULL
4. 确认 tty_cmd_cell 被调用

### 如果程序崩溃
1. 用 lldb/gdb 调试
2. 检查函数指针是否正确
3. 检查内存对齐问题
4. 简化到最小测试用例

---

## 🎉 预期成果

第四周结束时，我们应该能：

```
$ ./test_hello_tmux
=== Testing tmux Hello World ===
[UI_BACKEND] Initializing...
[UI_BACKEND] Setting callback: 0x1234567890
Sending: Hello from tmux
[UI_BACKEND] Got cell: 'H' (0x48)
[UI_BACKEND] Got cell: 'e' (0x65)
[UI_BACKEND] Got cell: 'l' (0x6c)
...
[UI_BACKEND] Flushing: 'Hello from tmux'
[TEST] Callback received: 'Hello from tmux'
=== Test Complete ===
```

这就是成功！虽然简单，但证明了整个架构是可行的。

---

**核心理念**: 不求完美，但求可见。先让它工作，再让它更好！