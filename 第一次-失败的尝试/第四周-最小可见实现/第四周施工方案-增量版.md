# ç¬¬å››å‘¨æ–½å·¥æ–¹æ¡ˆ - åŸºäºç¬¬ä¸‰å‘¨æˆæœçš„å¢é‡å®Œå–„
# Week 4 Implementation - Incremental Enhancement Based on Week 3

**åˆ›å»ºæ—¶é—´**: 2025-08-26  
**ç‰ˆæœ¬**: 6.0 (å¢é‡ç‰ˆ)  
**æ ¸å¿ƒç†å¿µ**: ä¸å¦å®šç¬¬ä¸‰å‘¨ï¼Œè€Œæ˜¯è¡¥å…¨ç¼ºå¤±çš„å…³é”®å®ç°  
**ç›®æ ‡**: è®©å·²æœ‰çš„æ¡†æ¶çœŸæ­£å·¥ä½œèµ·æ¥

---

## ğŸ¯ ç¬¬ä¸‰å‘¨æˆæœè¯„ä¼°ä¸ç¬¬å››å‘¨å®šä½

### ç¬¬ä¸‰å‘¨çš„æœ‰ä»·å€¼æˆæœ
âœ… **åŸºç¡€æ¡†æ¶å·²æ­å»º**
- tty.c è·¯ç”±é€»è¾‘å·²æ·»åŠ ï¼ˆLine 1741-1750ï¼‰
- ui_backend åŸºç¡€ç»“æ„å­˜åœ¨
- libtmuxcore.dylib å·²æ„å»º
- Ghostty FFI æ¨¡å—å·²åˆ›å»º

### ç¬¬ä¸‰å‘¨çš„å…³é”®ç¼ºå¤±
âŒ **æ ¸å¿ƒåŠŸèƒ½æœªå®ç°**
- ui_backend_dispatch åªæ˜¯ stubï¼ˆLine 93-97 æœ‰TODOï¼‰
- æ²¡æœ‰è¯†åˆ«å…·ä½“çš„ tty_cmd_* å‡½æ•°
- å›è°ƒå‡½æ•°è¡¨æœªå®šä¹‰å’Œè¿æ¥
- Terminal.zig æœªé›†æˆ

### ç¬¬å››å‘¨çš„ä»»åŠ¡
**è¡¥å…¨ç¼ºå¤±çš„å®ç°ï¼Œè®©æ¡†æ¶çœŸæ­£å·¥ä½œ**

---

## ğŸ“Š ç¬¬å››å‘¨å¢é‡å®ç°è®¡åˆ’

### Day 1-2: å¢å¼º ui_backend_dispatch å®ç°

#### ä»»åŠ¡ W4-INC-001: è®© ui_backend_dispatch çœŸæ­£å·¥ä½œ
**æ–‡ä»¶**: `tmux/ui_backend/ui_backend_dispatch.c` (æ–°å»º)
**ç›®æ ‡**: å®ç°çœŸæ­£çš„å‘½ä»¤åˆ†å‘

```c
// tmux/ui_backend/ui_backend_dispatch.c
#include "ui_backend.h"
#include "../tmux.h"
#include <stdio.h>

// å›è°ƒå‡½æ•°è¡¨ - è¿™æ˜¯ç¬¬ä¸‰å‘¨ç¼ºå¤±çš„å…³é”®éƒ¨åˆ†
typedef struct {
    void (*on_cell)(const char ch, int row, int col, void* user_data);
    void (*on_clear_line)(int row, void* user_data);
    void (*on_flush)(void* user_data);
} ui_callbacks_t;

static ui_callbacks_t g_callbacks = {0};
static void* g_user_data = NULL;

// è®¾ç½®å›è°ƒ - ä¾›Ghosttyè°ƒç”¨
void ui_backend_set_callbacks(ui_callbacks_t* callbacks, void* user_data) {
    if (callbacks) {
        g_callbacks = *callbacks;
        g_user_data = user_data;
        printf("[UI_BACKEND] Callbacks registered\n");
    }
}

// å¢å¼ºç‰ˆçš„ dispatch å‡½æ•° - æ›¿æ¢åŸæ¥çš„stub
int ui_backend_dispatch_enhanced(ui_backend_t* backend,
                                void (*cmdfn)(struct tty *, const struct tty_ctx *),
                                struct tty_ctx* ctx) {
    // æ£€æŸ¥æ˜¯å¦ä¸ºGHOSTTYæ¨¡å¼
    if (!backend || !ui_backend_enabled()) {
        return -1;
    }
    
    // è¯†åˆ«æ˜¯å“ªä¸ª tty_cmd_* å‡½æ•° - ç¬¬ä¸‰å‘¨ç¼ºå¤±çš„å…³é”®é€»è¾‘
    if (cmdfn == tty_cmd_cell) {
        printf("[DISPATCH] Processing tty_cmd_cell\n");
        
        if (ctx->cell && g_callbacks.on_cell) {
            struct grid_cell* gc = ctx->cell;
            char ch = gc->data.data[0];
            
            // è°ƒç”¨å›è°ƒ - å‘é€ç»™Ghostty
            g_callbacks.on_cell(ch, ctx->ocy, ctx->ocx, g_user_data);
            printf("[DISPATCH] Cell '%c' at (%d,%d) sent to callback\n", 
                   ch, ctx->ocy, ctx->ocx);
        }
        return 0; // å·²å¤„ç†
        
    } else if (cmdfn == tty_cmd_clearline) {
        printf("[DISPATCH] Processing tty_cmd_clearline\n");
        
        if (g_callbacks.on_clear_line) {
            g_callbacks.on_clear_line(ctx->ocy, g_user_data);
        }
        return 0; // å·²å¤„ç†
    }
    
    // å…¶ä»–å‘½ä»¤æš‚ä¸å¤„ç†
    return -1; // ä½¿ç”¨åŸè·¯å¾„
}
```

#### ä»»åŠ¡ W4-INC-002: ä¿®æ”¹ç°æœ‰ ui_backend.c è°ƒç”¨æ–°çš„ dispatch
**æ–‡ä»¶**: `tmux/ui_backend/ui_backend.c`
**ä¿®æ”¹**: Line 79-104

```c
// åœ¨ ui_backend.c ä¸­ä¿®æ”¹ ui_backend_dispatch å‡½æ•°
// æ›¿æ¢åŸæ¥çš„ TODO éƒ¨åˆ†

// å£°æ˜å¤–éƒ¨å‡½æ•°
extern int ui_backend_dispatch_enhanced(ui_backend_t* backend,
                                       void (*cmdfn)(struct tty *, const struct tty_ctx *),
                                       struct tty_ctx* ctx);

int ui_backend_dispatch(ui_backend_t* backend, 
                        void (*cmdfn)(struct tty *, const struct tty_ctx *),
                        struct tty_ctx* ctx) {
    #ifdef LIBTMUXCORE_BUILD
    if (!g_backend.enabled || g_backend.router == NULL) {
        return -1;
    }
    
    // ä½¿ç”¨å¢å¼ºç‰ˆçš„ dispatch
    if (g_backend.router->mode == ROUTER_MODE_GHOSTTY) {
        return ui_backend_dispatch_enhanced(backend, cmdfn, ctx);
    }
    
    return -1;
    #else
    return -1;
    #endif
}
```

### Day 3: åˆ›å»º C-Zig æ¡¥æ¥å±‚

#### ä»»åŠ¡ W4-INC-003: åˆ›å»º FFI æ¡¥æ¥å‡½æ•°
**æ–‡ä»¶**: `ghostty/src/tmux/ffi_bridge.zig`
**ç›®æ ‡**: è¿æ¥ C å›è°ƒåˆ° Zig

```zig
// ghostty/src/tmux/ffi_bridge.zig
const std = @import("std");

// C å›è°ƒå‡½æ•°ç±»å‹å®šä¹‰
pub const CellCallback = *const fn(ch: u8, row: c_int, col: c_int, user_data: ?*anyopaque) callconv(.C) void;
pub const ClearLineCallback = *const fn(row: c_int, user_data: ?*anyopaque) callconv(.C) void;
pub const FlushCallback = *const fn(user_data: ?*anyopaque) callconv(.C) void;

// å›è°ƒå‡½æ•°è¡¨ - å¯¹åº” C çš„ ui_callbacks_t
pub const UICallbacks = extern struct {
    on_cell: ?CellCallback,
    on_clear_line: ?ClearLineCallback,
    on_flush: ?FlushCallback,
};

// å¤–éƒ¨ C å‡½æ•°å£°æ˜
extern fn ui_backend_set_callbacks(callbacks: *const UICallbacks, user_data: ?*anyopaque) void;
extern fn ui_backend_init() void;
extern fn ui_backend_enabled() bool;

// Zig ç«¯çš„å›è°ƒå¤„ç†å™¨
pub const CallbackHandler = struct {
    grid: [][]u8,
    rows: usize,
    cols: usize,
    
    pub fn init(rows: usize, cols: usize, allocator: std.mem.Allocator) !CallbackHandler {
        var grid = try allocator.alloc([]u8, rows);
        for (grid) |*row| {
            row.* = try allocator.alloc(u8, cols);
            @memset(row.*, ' ');
        }
        
        return CallbackHandler{
            .grid = grid,
            .rows = rows,
            .cols = cols,
        };
    }
    
    // C å›è°ƒå®ç°
    pub fn onCell(ch: u8, row: c_int, col: c_int, user_data: ?*anyopaque) callconv(.C) void {
        const self = @ptrCast(*CallbackHandler, @alignCast(@alignOf(CallbackHandler), user_data));
        
        const r = @intCast(usize, row);
        const c = @intCast(usize, col);
        
        if (r < self.rows and c < self.cols) {
            self.grid[r][c] = ch;
            std.debug.print("[ZIG] Cell '{c}' at ({},{}) received\n", .{ch, r, c});
        }
    }
    
    pub fn onClearLine(row: c_int, user_data: ?*anyopaque) callconv(.C) void {
        const self = @ptrCast(*CallbackHandler, @alignCast(@alignOf(CallbackHandler), user_data));
        
        const r = @intCast(usize, row);
        if (r < self.rows) {
            @memset(self.grid[r], ' ');
            std.debug.print("[ZIG] Line {} cleared\n", .{r});
        }
    }
    
    pub fn onFlush(user_data: ?*anyopaque) callconv(.C) void {
        const self = @ptrCast(*CallbackHandler, @alignCast(@alignOf(CallbackHandler), user_data));
        std.debug.print("[ZIG] Flush requested\n", .{});
        self.displayGrid();
    }
    
    pub fn displayGrid(self: *CallbackHandler) void {
        std.debug.print("\n--- Grid Display ---\n", .{});
        for (self.grid) |row| {
            for (row) |ch| {
                std.debug.print("{c}", .{ch});
            }
            std.debug.print("\n", .{});
        }
        std.debug.print("--- End Display ---\n", .{});
    }
    
    pub fn registerCallbacks(self: *CallbackHandler) void {
        const callbacks = UICallbacks{
            .on_cell = onCell,
            .on_clear_line = onClearLine,
            .on_flush = onFlush,
        };
        
        ui_backend_set_callbacks(&callbacks, self);
        std.debug.print("[ZIG] Callbacks registered with UI Backend\n", .{});
    }
};
```

### Day 4: é›†æˆåˆ° Terminal.zig

#### ä»»åŠ¡ W4-INC-004: ä¿®æ”¹ Terminal.zig ä½¿ç”¨æ¡¥æ¥
**æ–‡ä»¶**: `ghostty/src/terminal/Terminal.zig`
**ç›®æ ‡**: åˆå§‹åŒ–å¹¶è¿æ¥å›è°ƒ

```zig
// åœ¨ Terminal.zig ä¸­æ·»åŠ 
const ffi_bridge = @import("../tmux/ffi_bridge.zig");

pub const Terminal = struct {
    // ... åŸæœ‰å­—æ®µ
    
    // æ–°å¢
    tmux_handler: ?*ffi_bridge.CallbackHandler,
    
    pub fn init(allocator: std.mem.Allocator, config: Config) !Terminal {
        var self = Terminal{
            // ... åŸæœ‰åˆå§‹åŒ–
            .tmux_handler = null,
        };
        
        // æ£€æŸ¥ç¯å¢ƒå˜é‡
        if (std.process.getEnv("GHOSTTY_TMUX")) |_| {
            std.debug.print("[TERMINAL] Initializing tmux mode\n", .{});
            
            // åˆå§‹åŒ– UI Backend
            ffi_bridge.ui_backend_init();
            
            // åˆ›å»ºå›è°ƒå¤„ç†å™¨
            self.tmux_handler = try allocator.create(ffi_bridge.CallbackHandler);
            self.tmux_handler.?.* = try ffi_bridge.CallbackHandler.init(
                config.rows, 
                config.cols, 
                allocator
            );
            
            // æ³¨å†Œå›è°ƒ
            self.tmux_handler.?.registerCallbacks();
            
            std.debug.print("[TERMINAL] tmux callbacks registered\n", .{});
        }
        
        return self;
    }
    
    pub fn render(self: *Terminal) void {
        if (self.tmux_handler) |handler| {
            // æ˜¾ç¤º tmux çš„ grid
            handler.displayGrid();
        } else {
            // æ™®é€šæ¸²æŸ“
            self.renderNormal();
        }
    }
};
```

### Day 5: åˆ›å»ºæµ‹è¯•ç¨‹åº

#### ä»»åŠ¡ W4-INC-005: åˆ›å»ºç«¯åˆ°ç«¯æµ‹è¯•
**æ–‡ä»¶**: `test_week4_integration.c`
**ç›®æ ‡**: éªŒè¯æ•´ä¸ªé“¾è·¯

```c
// test_week4_integration.c
#include <stdio.h>
#include <string.h>
#include "../tmux/tmux.h"
#include "../tmux/ui_backend/ui_backend.h"

// æ¨¡æ‹Ÿ tty_cmd_cell å‡½æ•°
void tty_cmd_cell(struct tty* tty, const struct tty_ctx* ctx) {
    printf("[TEST] Original tty_cmd_cell called\n");
}

// æµ‹è¯•å›è°ƒ
void test_on_cell(char ch, int row, int col, void* user_data) {
    printf("[TEST CALLBACK] Received cell '%c' at (%d,%d)\n", ch, row, col);
}

int main() {
    printf("=== Week 4 Integration Test ===\n");
    
    // è®¾ç½®ç¯å¢ƒå˜é‡
    setenv("TMUX_UI_BACKEND", "ghostty", 1);
    
    // åˆå§‹åŒ– UI Backend
    ui_backend_init();
    
    // è®¾ç½®æµ‹è¯•å›è°ƒ
    ui_callbacks_t callbacks = {
        .on_cell = test_on_cell,
        .on_clear_line = NULL,
        .on_flush = NULL
    };
    ui_backend_set_callbacks(&callbacks, NULL);
    
    // åˆ›å»ºæµ‹è¯•æ•°æ®
    struct grid_cell cell = {
        .data = { .data = "H" },
    };
    
    struct tty_ctx ctx = {
        .cell = &cell,
        .ocy = 0,
        .ocx = 0,
    };
    
    // æµ‹è¯• dispatch
    ui_backend_t* backend = ui_backend_get_instance();
    int result = ui_backend_dispatch(backend, tty_cmd_cell, &ctx);
    
    if (result == 0) {
        printf("âœ… Dispatch successful - callback should have been called\n");
    } else {
        printf("âŒ Dispatch failed\n");
    }
    
    printf("=== Test Complete ===\n");
    return 0;
}
```

### Day 6: æ„å»ºå’Œæµ‹è¯•è„šæœ¬

#### ä»»åŠ¡ W4-INC-006: åˆ›å»ºå¢é‡æ„å»ºè„šæœ¬
**æ–‡ä»¶**: `build_week4.sh`

```bash
#!/bin/bash
set -e

echo "=== Week 4 Incremental Build ==="

# ç¼–è¯‘æ–°çš„ dispatch å®ç°
cd tmux/ui_backend
gcc -c -fPIC ui_backend_dispatch.c -o ui_backend_dispatch.o

# é‡æ–°é“¾æ¥ libtmuxcore.dylib
cd ..
gcc -dynamiclib -o libtmuxcore.dylib \
    ui_backend/*.o \
    -DLIBTMUXCORE_BUILD

echo "âœ… libtmuxcore.dylib updated"

# ç¼–è¯‘æµ‹è¯•ç¨‹åº
gcc -o test_week4 test_week4_integration.c \
    -L. -ltmuxcore \
    -DLIBTMUXCORE_BUILD

# è¿è¡Œæµ‹è¯•
export DYLD_LIBRARY_PATH=.:$DYLD_LIBRARY_PATH
./test_week4

echo "=== Build Complete ==="
```

---

## ğŸ¯ ç¬¬å››å‘¨æˆåŠŸæ ‡å‡†

### æœ€å°ç›®æ ‡
âœ… ui_backend_dispatch èƒ½è¯†åˆ« tty_cmd_cell  
âœ… å›è°ƒå‡½æ•°è¢«æ­£ç¡®è§¦å‘  
âœ… Zig ç«¯èƒ½æ¥æ”¶åˆ°å­—ç¬¦æ•°æ®  
âœ… èƒ½çœ‹åˆ° "H" å­—ç¬¦è¢«å¤„ç†  

### å¢é‡æ”¹è¿›
- åŸºäºç¬¬ä¸‰å‘¨çš„æ¡†æ¶å·¥ä½œ
- ä¸æ¨ç¿»é‡æ¥ï¼Œè€Œæ˜¯è¡¥å…¨ç¼ºå¤±
- ä¿æŒä»£ç è¿ç»­æ€§

---

## ğŸ’¡ ä¸ºä»€ä¹ˆè¿™ä¸ªæ–¹æ¡ˆæ›´å¥½

1. **å°Šé‡ç¬¬ä¸‰å‘¨çš„å·¥ä½œ** - ä¸å¦å®šå·²æœ‰æˆæœ
2. **å¢é‡æ”¹è¿›** - åªè¡¥å……ç¼ºå¤±çš„éƒ¨åˆ†
3. **æ˜ç¡®çš„é—®é¢˜å®šä½** - ui_backend_dispatch éœ€è¦çœŸæ­£å®ç°
4. **å¯éªŒè¯çš„è¿›å±•** - æ¯ä¸€æ­¥éƒ½èƒ½çœ‹åˆ°æ•ˆæœ

è¿™ä¸ªæ–¹æ¡ˆæ‰¿è®¤ç¬¬ä¸‰å‘¨çš„ä»·å€¼ï¼ŒåŒæ—¶è¡¥å…¨äº†å…³é”®çš„ç¼ºå¤±éƒ¨åˆ†ï¼