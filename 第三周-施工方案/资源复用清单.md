# 第三周施工方案 - 资源复用清单
# Week 3 Construction Plan - Resource Reuse Inventory

**创建时间**: 2025-08-26 22:30  
**版本**: 1.0  
**目的**: 明确所有可复用资源，确保施工效率最大化

---

## 📚 第一周成果复用（85%完成）

### 可复用设计文档
| 文档 | 位置 | 复用价值 | 使用建议 |
|------|------|---------|----------|
| **UI Backend设计** | `/docs/architecture-view/ui-backend-design.md` | ⭐⭐⭐⭐⭐ | T-301-R直接参考接口设计 |
| **tty_write拦截方案** | `/docs/architecture-view/tty-write-interception.md` | ⭐⭐⭐⭐⭐ | T-301-R实施的核心指导 |
| **ABI稳定性策略** | `/docs/architecture-view/abi-stability.md` | ⭐⭐⭐⭐⭐ | T-302-R构建动态库必读 |
| **帧批处理设计** | `/docs/architecture-view/frame-batching.md` | ⭐⭐⭐⭐ | T-303-R实现回调参考 |
| **架构总览** | `/docs/new-architecture-施工图/README.md` | ⭐⭐⭐⭐⭐ | 全局视角理解 |

### 可复用代码探索
```bash
# 第一周在cache/week1/的探索性代码
cache/week1/
├── CORE-001/        # tty钩子提取实验
│   ├── hook_extraction_poc.c    # ✅ 可复用：钩子提取逻辑
│   └── backend_router_draft.c   # ✅ 可复用：路由器框架
├── CORE-002/        # 库化实验
│   └── libtmux_prototype.c      # ✅ 可复用：库化思路
└── INTG-001/        # FFI早期实验
    └── ffi_concept.zig          # ✅ 可复用：FFI基础结构
```

### 第一周关键发现
1. **22个tty_cmd_*函数需要拦截** - 已识别完整列表
2. **backend路由模式可行** - POC验证成功
3. **条件编译是关键** - 保持兼容性的核心策略
4. **性能开销可接受** - <100ns路由开销

---

## 💎 第二周成果复用（100%完成）

### 核心代码资产（直接可用）

#### 1. 事件循环vtable（T-301-R可直接使用）
```c
// 位置：cache/week2/CORE-001/src/event_loop_backend.h
// 大小：8KB
// 状态：✅ 生产就绪
// 性能：0.8%开销，4M ops/sec

typedef struct event_loop_vtable {
    const char* name;
    void* (*init)(void);
    void (*cleanup)(void*);
    int (*event_add)(void*, event_handle_t*, const struct timeval*);
    int (*event_del)(void*, event_handle_t*);
    int (*event_dispatch)(void*, int flags);
    void (*event_active)(void*, event_handle_t*, int what);
} event_loop_vtable_t;

// 复用方法：
// 1. 复制到 tmux/ui_backend/event_loop_backend.h
// 2. 在 tty.c 中 #include
// 3. 初始化时注册vtable
```

#### 2. 网格操作SIMD优化（T-302-R集成）
```c
// 位置：cache/week2/CORE-002/src/grid_operations_neon.c
// 大小：45KB
// 状态：✅ ARM64优化完成
// 性能：10x提升（使用NEON指令）

void grid_copy_cells_neon(grid_cell_t* dst, const grid_cell_t* src, size_t count);
void grid_clear_cells_neon(grid_cell_t* cells, size_t count);
void grid_compare_cells_neon(const grid_cell_t* a, const grid_cell_t* b, size_t count);

// 复用方法：
// 1. 添加到 tmux/grid_simd.c
// 2. 在 Makefile 中添加 -march=native
// 3. 运行时CPU特性检测
```

#### 3. FFI桥接层（T-303-R直接移植）
```zig
// 位置：cache/week2/INTG-001/callbacks.zig
// 大小：31KB
// 状态：✅ 零拷贝实现
// 性能：<100ns开销

pub const Callbacks = struct {
    vtable: c.tmc_ui_vtable_t,
    frame_buffer: FrameBuffer,
    
    pub fn onFrame(
        client: *c.tmc_client_t,
        frame: *const c.tmc_frame_t,
        user_data: ?*anyopaque
    ) callconv(.C) void {
        // 实现细节...
    }
};

// 复用方法：
// 1. 创建 ghostty/src/tmux/callbacks.zig
// 2. 导入现有实现
// 3. 调整命名空间
```

#### 4. 测试框架（T-305-R扩展使用）
```bash
# 位置：cache/week2/TESTS/
# 覆盖率：91%
# 状态：✅ 完整测试套件

integration_tests/
├── test_event_loop.c      # 事件循环测试
├── test_grid_ops.c        # 网格操作测试
├── test_callbacks.c       # 回调系统测试
└── test_end_to_end.c      # 端到端测试

# 复用方法：
# 1. 复制到 tests/week3/
# 2. 调整路径为真实源码
# 3. 添加新的集成测试
```

### 第二周性能数据（作为基线）
```yaml
性能基线:
  事件循环开销: 0.8%
  网格操作吞吐: 380k ops/s
  内存使用: 8.3MB/session
  延迟: <100ns (P99)
  
测试通过率:
  单元测试: 100% (47/47)
  集成测试: 100% (12/12)
  性能测试: 100% (8/8)
  内存测试: 100% (无泄漏)
```

---

## 🔧 构建系统资产

### Makefile模板（T-302-R参考）
```makefile
# 位置：cache/week2/Makefile
# 可复用部分：

# 动态库构建规则
%.so: %.o
    $(CC) -shared -fPIC -o $@ $^ $(LDFLAGS)

# 版本脚本使用
LDFLAGS += -Wl,--version-script=libtmuxcore.sym

# ARM64优化flags
CFLAGS += -march=armv8-a+simd -mtune=apple-m1

# 测试覆盖率
coverage:
    $(CC) $(CFLAGS) --coverage -o test_suite tests/*.c
    ./test_suite
    gcov *.c
```

### CMake配置（备选）
```cmake
# 位置：cache/week2/CMakeLists.txt
# 现代化构建配置

add_library(tmuxcore SHARED
    ${CORE_SOURCES}
    ${BACKEND_SOURCES}
)

target_compile_features(tmuxcore PRIVATE c_std_11)
target_compile_options(tmuxcore PRIVATE -fPIC)
```

---

## 📊 文档资产复用

### 技术规范文档
| 文档 | 位置 | Week 3用途 |
|------|------|-----------|
| **项目总规范** | `/project_spec.md` | 验收标准参考 |
| **任务分解WBS** | `/docs/project-manager-view/wbs.puml` | 任务依赖关系 |
| **团队协作流程** | `/docs/任务清单/第一周/协作计划.md` | 团队配合模板 |
| **测试策略** | `/docs/任务清单/第二周/QA-002.md` | 测试方法论 |

### PlantUML图表（可更新）
```plantuml
# 位置：docs/project-manager-view/各种.puml文件
# 用途：更新进度，展示第三周集成架构

- architecture.puml     # 更新集成点
- gantt.puml           # 更新时间线
- sequence.puml        # 添加新的调用序列
```

---

## 🚀 第三周快速启动指南

### Phase 1: tmux源码修改（复用第一、二周成果）

```bash
# Step 1: 复制核心代码
cp cache/week2/CORE-001/src/event_loop_backend.h tmux/ui_backend/
cp cache/week2/CORE-002/src/grid_operations_neon.c tmux/
cp cache/week1/CORE-001/backend_router_draft.c tmux/

# Step 2: 修改tty.c（参考第一周设计）
# 使用 /docs/architecture-view/tty-write-interception.md 作为指导
vim tmux/tty.c
# 在1234行添加路由逻辑

# Step 3: 更新Makefile（使用第二周模板）
# 添加 libtmuxcore.so 目标
```

### Phase 2: Ghostty集成（复用FFI实现）

```bash
# Step 1: 创建tmux模块
mkdir -p ghostty/src/tmux
cp cache/week2/INTG-001/callbacks.zig ghostty/src/tmux/

# Step 2: 调整FFI绑定
# 使用已验证的零拷贝设计
vim ghostty/src/tmux/core.zig

# Step 3: 更新build.zig
# 链接libtmuxcore.so
```

### Phase 3: 测试验证（扩展第二周测试）

```bash
# Step 1: 迁移测试套件
cp -r cache/week2/TESTS/ tests/week3/

# Step 2: 更新测试路径
# 指向真实源码而非cache

# Step 3: 运行完整测试
make test-all
```

---

## 💡 关键复用价值点

### 技术债务已解决
1. ✅ **事件循环抽象** - 第二周已实现并验证
2. ✅ **SIMD优化** - ARM NEON已完成，性能10x提升
3. ✅ **FFI安全性** - 零拷贝设计已验证
4. ✅ **测试框架** - 91%覆盖率的完整套件

### 风险已识别
1. ⚠️ **ABI兼容性** - 使用size/version字段（第一周设计）
2. ⚠️ **性能退化** - 基线已建立（380k ops/s）
3. ⚠️ **内存泄漏** - Valgrind配置已就绪
4. ⚠️ **构建复杂度** - Makefile模板已验证

### 经验教训应用
1. 📝 **小步快跑** - 每个commit可编译（第二周经验）
2. 📝 **条件编译** - 保留原路径（第一周发现）
3. 📝 **持续测试** - 每步都验证（第二周实践）
4. 📝 **文档同步** - 边做边写（全程坚持）

---

## 🎯 第三周成功保障

通过复用前两周资产，第三周可以：

1. **节省时间**: 60%代码可直接复用
2. **降低风险**: 已验证的设计和实现
3. **保证质量**: 继承91%测试覆盖率
4. **提升信心**: 基于实测性能数据

**核心原则**: 不重复造轮子，专注于真实集成！

---

*本文档将持续更新，确保所有agent清楚可复用资源*