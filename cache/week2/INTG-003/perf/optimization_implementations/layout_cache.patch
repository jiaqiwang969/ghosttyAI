diff --git a/cache/week2/CORE-001/layout/src/layout_manager.c b/cache/week2/CORE-001/layout/src/layout_manager.c
index original..optimized
--- a/cache/week2/CORE-001/layout/src/layout_manager.c
+++ b/cache/week2/CORE-001/layout/src/layout_manager.c
@@ -8,10 +8,87 @@
 #include <string.h>
 #include "../include/layout_callbacks.h"
 
+// ============================================================================
+// Layout Cache Implementation
+// ============================================================================
+
+#define CACHE_SIZE 128
+#define CACHE_LINE_SIZE 64
+#define likely(x) __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+
+typedef struct __attribute__((aligned(CACHE_LINE_SIZE))) {
+    uint32_t hash;
+    uint32_t hits;
+    uint64_t last_access;
+    layout_t* layout;
+    char padding[CACHE_LINE_SIZE - 24 - sizeof(layout_t*)];
+} cache_entry_t;
+
+typedef struct {
+    cache_entry_t entries[CACHE_SIZE];
+    uint64_t total_hits;
+    uint64_t total_misses;
+    uint64_t access_counter;
+} layout_cache_t;
+
+static layout_cache_t g_layout_cache = {0};
+
+// Fast hash function for layout configuration
+static inline uint32_t hash_layout_config(int width, int height, int pane_count, int layout_type) {
+    uint32_t hash = width;
+    hash = ((hash << 5) + hash) + height;
+    hash = ((hash << 5) + hash) + pane_count;
+    hash = ((hash << 5) + hash) + layout_type;
+    return hash;
+}
+
+// LRU cache replacement
+static inline cache_entry_t* find_lru_entry(void) {
+    uint64_t oldest = UINT64_MAX;
+    cache_entry_t* lru = &g_layout_cache.entries[0];
+    
+    for (int i = 0; i < CACHE_SIZE; i++) {
+        if (g_layout_cache.entries[i].last_access < oldest) {
+            oldest = g_layout_cache.entries[i].last_access;
+            lru = &g_layout_cache.entries[i];
+        }
+    }
+    
+    return lru;
+}
+
+// Cache lookup with prefetching
+static inline layout_t* cache_lookup(uint32_t hash) {
+    const int slot = hash % CACHE_SIZE;
+    cache_entry_t* entry = &g_layout_cache.entries[slot];
+    
+    // Prefetch next likely entries
+    __builtin_prefetch(&g_layout_cache.entries[(slot + 1) % CACHE_SIZE], 0, 1);
+    
+    if (likely(entry->hash == hash && entry->layout != NULL)) {
+        // Cache hit
+        entry->hits++;
+        entry->last_access = ++g_layout_cache.access_counter;
+        __atomic_fetch_add(&g_layout_cache.total_hits, 1, __ATOMIC_RELAXED);
+        return entry->layout;
+    }
+    
+    __atomic_fetch_add(&g_layout_cache.total_misses, 1, __ATOMIC_RELAXED);
+    return NULL;
+}
+
+// Cache insertion
+static inline void cache_insert(uint32_t hash, layout_t* layout) {
+    cache_entry_t* entry = find_lru_entry();
+    
+    entry->hash = hash;
+    entry->layout = layout;
+    entry->hits = 1;
+    entry->last_access = ++g_layout_cache.access_counter;
+}
+
 // ============================================================================
 // Layout Manager Implementation
 // ============================================================================
 
 typedef struct {
     int width;
     int height;
@@ -21,10 +98,28 @@ typedef struct {
 
 layout_t* layout_calculate(int width, int height, int pane_count, layout_type_t type) {
+    // Check cache first
+    uint32_t hash = hash_layout_config(width, height, pane_count, type);
+    layout_t* cached = cache_lookup(hash);
+    
+    if (cached != NULL) {
+        return cached;  // Fast path - cached result
+    }
+    
+    // Slow path - calculate layout
     layout_t* layout = malloc(sizeof(layout_t));
     if (!layout) return NULL;
     
     layout->width = width;
     layout->height = height;
     layout->type = type;
     layout->pane_count = pane_count;
+    
+    // Pre-calculate common layouts
+    switch (type) {
+        case LAYOUT_EVEN_HORIZONTAL:
+            calculate_even_horizontal(layout);
+            break;
+        case LAYOUT_EVEN_VERTICAL:
+            calculate_even_vertical(layout);
+            break;
+        case LAYOUT_MAIN_HORIZONTAL:
+            calculate_main_horizontal(layout);
+            break;
+        case LAYOUT_MAIN_VERTICAL:
+            calculate_main_vertical(layout);
+            break;
+        case LAYOUT_TILED:
+            calculate_tiled(layout);
+            break;
+    }
+    
+    // Cache the result
+    cache_insert(hash, layout);
     
     return layout;
+}
+
+// ============================================================================
+// Optimized Layout Calculations
+// ============================================================================
+
+static inline void calculate_even_horizontal(layout_t* layout) {
+    const int pane_width = layout->width / layout->pane_count;
+    const int remainder = layout->width % layout->pane_count;
+    
+    // Vectorized calculation for pane positions
+    for (int i = 0; i < layout->pane_count; i++) {
+        layout->panes[i].x = i * pane_width + (i < remainder ? i : remainder);
+        layout->panes[i].y = 0;
+        layout->panes[i].width = pane_width + (i < remainder ? 1 : 0);
+        layout->panes[i].height = layout->height;
+    }
+}
+
+static inline void calculate_even_vertical(layout_t* layout) {
+    const int pane_height = layout->height / layout->pane_count;
+    const int remainder = layout->height % layout->pane_count;
+    
+    for (int i = 0; i < layout->pane_count; i++) {
+        layout->panes[i].x = 0;
+        layout->panes[i].y = i * pane_height + (i < remainder ? i : remainder);
+        layout->panes[i].width = layout->width;
+        layout->panes[i].height = pane_height + (i < remainder ? 1 : 0);
+    }
+}
+
+// ============================================================================
+// Fast Layout Switch with Transition
+// ============================================================================
+
+int layout_switch_optimized(layout_manager_t* manager, layout_type_t new_type) {
+    // Pre-calculate new layout while old is still active
+    uint32_t hash = hash_layout_config(manager->width, manager->height, 
+                                       manager->pane_count, new_type);
+    
+    // Check if already calculated
+    layout_t* new_layout = cache_lookup(hash);
+    
+    if (new_layout == NULL) {
+        // Calculate in parallel if possible
+        new_layout = layout_calculate(manager->width, manager->height,
+                                      manager->pane_count, new_type);
+    }
+    
+    // Atomic pointer swap for instant switch
+    layout_t* old = __atomic_exchange_n(&manager->current_layout, new_layout, __ATOMIC_SEQ_CST);
+    
+    // Clean up old layout (deferred)
+    if (old != new_layout) {
+        // Could defer this to avoid blocking
+        free(old);
+    }
+    
+    return 0;
+}
+
+// ============================================================================
+// Cache Statistics
+// ============================================================================
+
+void layout_cache_stats(double* hit_rate, size_t* memory_usage) {
+    uint64_t hits = __atomic_load_n(&g_layout_cache.total_hits, __ATOMIC_RELAXED);
+    uint64_t misses = __atomic_load_n(&g_layout_cache.total_misses, __ATOMIC_RELAXED);
+    
+    uint64_t total = hits + misses;
+    *hit_rate = total > 0 ? (double)hits / total : 0.0;
+    
+    *memory_usage = sizeof(g_layout_cache);
+    for (int i = 0; i < CACHE_SIZE; i++) {
+        if (g_layout_cache.entries[i].layout != NULL) {
+            *memory_usage += sizeof(layout_t);
+        }
+    }
+}
+
+// Pre-warm cache with common layouts
+void layout_cache_prewarm(void) {
+    // Common terminal sizes
+    int common_widths[] = {80, 120, 160, 200};
+    int common_heights[] = {24, 40, 50, 60};
+    int common_panes[] = {1, 2, 3, 4};
+    
+    for (int w = 0; w < 4; w++) {
+        for (int h = 0; h < 4; h++) {
+            for (int p = 0; p < 4; p++) {
+                // Pre-calculate all layout types
+                for (int t = 0; t < LAYOUT_TYPE_COUNT; t++) {
+                    layout_calculate(common_widths[w], common_heights[h],
+                                   common_panes[p], t);
+                }
+            }
+        }
+    }
 }