diff --git a/cache/week2/CORE-001/src/event_loop_router.c b/cache/week2/CORE-001/src/event_loop_router.c
index original..optimized 100644
--- a/cache/week2/CORE-001/src/event_loop_router.c
+++ b/cache/week2/CORE-001/src/event_loop_router.c
@@ -14,6 +14,20 @@
 #include <event2/event.h>  // For libevent backend
 #include "event_loop_backend.h"
 
+// ============================================================================
+// Performance Optimizations
+// ============================================================================
+
+// Branch prediction hints
+#define likely(x)   __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+
+// Cache line size for alignment
+#define CACHE_LINE_SIZE 64
+
+// Object pool for event handles
+#define EVENT_POOL_SIZE 1024
+static event_handle_t* event_pool[EVENT_POOL_SIZE];
+static int event_pool_count = 0;
+
 // ============================================================================
 // Thread Safety
 // ============================================================================
@@ -39,11 +53,27 @@ static void libevent_cleanup(void* base) {
 }
 
 static int libevent_event_add(void* base, event_handle_t* handle, const struct timeval* timeout) {
+    // OPTIMIZATION: Fast path for already initialized events
+    if (likely(handle->backend_data != NULL)) {
+        return event_add((struct event*)handle->backend_data, timeout);
+    }
+    
     struct event* ev = (struct event*)handle->backend_data;
     if (!ev) {
         ev = event_new((struct event_base*)base, handle->fd, handle->events,
                       handle->callback, handle->user_data);
         handle->backend_data = ev;
+        
+        // OPTIMIZATION: Prefetch next cache line for better locality
+        __builtin_prefetch(handle + 1, 0, 1);
     }
     return event_add(ev, timeout);
 }
@@ -136,6 +166,41 @@ event_loop_router_t* event_loop_router_init(router_mode_t mode) {
     return router;
 }
 
+// OPTIMIZATION: Inline hot path for event addition
+static inline int event_loop_add_fast(event_loop_router_t* router, 
+                                      event_handle_t* handle,
+                                      const struct timeval* timeout) {
+    // Skip vtable for libevent mode (common case)
+    if (likely(router->mode == ROUTER_MODE_LIBEVENT)) {
+        struct event* ev = (struct event*)handle->backend_data;
+        if (likely(ev != NULL)) {
+            return event_add(ev, timeout);
+        }
+    }
+    
+    // Fall back to vtable dispatch
+    return router->vtable->event_add(router->backend_base, handle, timeout);
+}
+
+// OPTIMIZATION: Object pool for event handles
+event_handle_t* event_loop_create_event_pooled(event_loop_router_t* router) {
+    event_handle_t* handle = NULL;
+    
+    // Try to get from pool first
+    if (event_pool_count > 0) {
+        handle = event_pool[--event_pool_count];
+        memset(handle, 0, sizeof(event_handle_t));
+    } else {
+        // Allocate aligned for better cache performance
+        if (posix_memalign((void**)&handle, CACHE_LINE_SIZE, sizeof(event_handle_t)) != 0) {
+            return NULL;
+        }
+        memset(handle, 0, sizeof(event_handle_t));
+    }
+    
+    return handle;
+}
+
+// OPTIMIZATION: Return to pool instead of freeing
+void event_loop_free_event_pooled(event_loop_router_t* router, event_handle_t* handle) {
+    if (handle == NULL) return;
+    
+    // Clean up backend data
+    if (handle->backend_data && router->vtable->event_del) {
+        router->vtable->event_del(router->backend_base, handle);
+    }
+    
+    // Return to pool if space available
+    if (event_pool_count < EVENT_POOL_SIZE) {
+        event_pool[event_pool_count++] = handle;
+    } else {
+        free(handle);
+    }
+}
+
 // Public API implementation
 int event_loop_add(event_loop_router_t* router, event_handle_t* handle, 
                   const struct timeval* timeout) {
-    return router->vtable->event_add(router->backend_base, handle, timeout);
+    // OPTIMIZATION: Use fast path
+    return event_loop_add_fast(router, handle, timeout);
 }
 
 // ... rest of implementation ...